# **Инструкция: как превращать учебные материалы в JSON-структуру для приложения**

Эта инструкция описывает процесс преобразования обучающих материалов (например, статей в формате Markdown) в структурированный JSON, который используется в текущем приложении (Next.js 15, React 18) для подготовки к интервью.

Что важно в актуальной версии проекта:
- Поддерживаются только три типа секций: `text`, `code_task`, `quiz` (изображения/видео пока не поддерживаются схемой).
- В каждой секции можно (опционально) хранить мини-чат `ai_chat_history`. Сообщения имеют поля `role` и `text` (а не `message`), `ts` — опционально.
- Файл урока должен лежать в `public/two_sum_full.json` (страница сейчас читает именно этот путь). Чтобы увидеть свой урок, временно замените этот файл или сохраните под этим именем.
- `text.content` поддерживает Markdown (включая GFM — таблицы, чекбоксы и т. п.).
- Для `code_task` тесты могут иметь произвольные входы/ожидаемые значения. Функция решения должна быть объявлена первой в коде, чтобы раннер корректно её обнаружил.

---

## **1. Общая структура JSON**

Каждая тема оформляется в виде JSON-объекта, содержащего метаданные и список секций:

```json
{
  "id": "two_sum",
  "title": "Two Sum — A complete, student-friendly guide",
  "difficulty": "Easy",
  "topics": ["Array", "Hash Table"],
  "goal": "Given an array nums and an integer target...",
  "sections": [
    {...},
    {...}
  ],
  "created_at": "2025-10-21T16:43:50.397Z"
}
```

Пояснения:
- `difficulty` — опционально; в приложении нормализуется к нижнему регистру (например, `"Easy"` → `"easy"`). Рекомендуемые значения: `easy`, `medium`, `hard`.
- `topics`, `goal`, `created_at` — опциональные поля.

---

## **2. Типы секций**

Секции представляют отдельные части темы. Основные типы:

- **text** — теоретический материал/объяснение (контент в Markdown)
- **code_task** — практическое задание с автотестами
- **quiz** — мини-тест для проверки понимания

Примечание: типы `image`/`video` сейчас не поддерживаются схемой и будут отклонены валидатором.

---

## **3. Разбор исходного материала (Markdown → JSON)**

Для каждой секции исходного текста нужно определить её тип и перенести ключевую информацию.

✅ **Заголовки** → `text` секции  
✅ **Код и алгоритмы** → `code_task` секции  
✅ **Вопросы** → `quiz` секции  
✅ **ai_chat_history** — можно добавить под каждой секцией (опционально; по умолчанию пустая)

---

## **4. Пример `code_task` секции**

```json
{
  "type": "code_task",
  "title": "Two Sum — Brute Force",
  "description": "Implement the O(n²) brute-force approach for small arrays.",
  "starter_code": "def two_sum_bruteforce(nums, target):\n    # TODO: implement\n    pass",
  "tests": [
    {"input": {"nums": [2,7,11,15], "target": 9}, "expected": [0,1]}
  "tests": [
    {"input": {"nums": [2,7,11,15], "target": 9}, "expected": [0,1]},
    {"name": "basic-2", "input": {"nums": [3,2,4], "target": 6}, "expected": [1,2]}
  ],
}
  "ai_chat_history": []

---

Важно:
- Функция решения должна быть объявлена первой в `starter_code` (например, `function twoSum(...) {}`). Раннер извлекает имя первой объявленной функции и вызывает её в тестах.
- Формат входа тестов `input`:
  - Массив аргументов: `input: [arg1, arg2, ...]` будет вызвано как `fn(arg1, arg2, ...)`.
  - Объект: `input: {a: 1, b: 2}` будет вызвано как `fn(1, 2)` в порядке полей объекта. Чтобы избежать неоднозначности, отдавайте предпочтение массиву.
- Поле `name` у теста опционально. Если не указано — название будет сгенерировано автоматически.

## **5. Пример `quiz` секции**

```json
{
  "type": "quiz",
  "title": "Quick check",
  "questions": [
    {
      "question": "What is the average time complexity of the hash map solution?",
      "options": ["O(n²)", "O(log n)", "O(n)", "O(1)"],
      "answer": "O(n)"
    }
      "answer": "O(n)"
  "ai_chat_history": []
}
```

---

Правила для викторины:
- В каждом вопросе `options` — минимум 2 варианта.
- `answer` должен совпадать с одним из вариантов в `options`.

## **6. Мини-чаты (`ai_chat_history`)**

Каждая секция может содержать встроенный мини-чат для взаимодействия с AI.

```json
"ai_chat_history": [
  {"role": "user", "message": "Почему хэш-таблица быстрее двойного цикла?"},
  {"role": "assistant", "message": "Потому что поиск в хэш-таблице выполняется за O(1) в среднем."}
  {"role": "user", "text": "Почему хэш-таблица быстрее двойного цикла?", "ts": 1697890000000},
  {"role": "assistant", "text": "Потому что поиск в хэш-таблице выполняется за O(1) в среднем."}

---

Структура сообщения:
- `role`: `"user" | "assistant"`
- `text`: строка с сообщением
- `ts`: опционально, число (timestamp в мс)

## **7. Шаги ручного преобразования**

1. Прочитать исходный Markdown-файл  
2. Извлечь метаданные (`title`, `difficulty`, `topics`, `goal`)  
3. Каждый заголовок `#` или `##` превратить в секцию типа **text**  
4. Кодовые блоки оформить как **code_task**  
5. Вопросы оформить как **quiz**  
6. Добавить `ai_chat_history` в каждую секцию (пустой массив)  
7. Проверить JSON и сохранить как `<topic>_module_with_ai.json`
6. При необходимости добавить `ai_chat_history` (или опустить — по умолчанию будет пустым)  
7. Проверить JSON и сохранить в файл `public/two_sum_full.json` (на текущем этапе страница приложения читает именно этот путь)

## **8. Шаблон для новых тем**

```json
{
  "id": "topic_id",
  "title": "Topic Name",
  "difficulty": "Medium",
  "topics": ["Category1", "Category2"],
  "goal": "Short summary of the task.",
  "sections": [
    {
      "type": "text",
      "title": "Concept overview",
      "content": "Explain the concept..."
    },
      "content": "Explain the concept in Markdown..."
      "type": "code_task",
      "title": "Main exercise",
      "description": "Implement the algorithm.",
      "starter_code": "",
      "tests": [],
      "hints": [],
      "ai_chat_history": []
    },
    {
      "type": "quiz",
      "title": "Check your understanding",
      "questions": [],
      "ai_chat_history": []
    }
  ]
}
  ],
  "created_at": "2025-10-21T16:43:50.397Z"

---

## **9. Возможная автоматизация**

Можно написать Python-скрипт, который парсит Markdown и автоматически создаёт JSON по этому шаблону  
(используя библиотеки `markdown`, `BeautifulSoup`, `re`).
Рекомендуется проверить структуру файла тестами проекта (используется Zod-схема):

1) Поместите файл в `public/two_sum_full.json` (замените существующий для проверки).  
2) Запустите тесты проекта — они включают проверку схемы урока.

Автоматизация:
- Вариант на Node.js/TypeScript: написать скрипт, который парсит Markdown и собирает JSON согласно схеме (`lib/schemas/lesson.ts`), затем валидирует его через Zod перед сохранением.
- Опционально Python: можно использовать `markdown`, `BeautifulSoup`, `re` для парсинга и генерации JSON.

Подсказки по содержанию:
- Соблюдайте порядок аргументов для функций в `code_task` тестах. Надёжнее всего передавать входы массивом.
- В `text` используйте Markdown (GFM) — заголовки, списки, таблицы будут корректно отображаться.
