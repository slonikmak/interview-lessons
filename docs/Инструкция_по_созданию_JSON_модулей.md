# **Инструкция: как превращать учебные материалы в JSON-структуру для приложения**

Эта инструкция описывает процесс преобразования обучающих материалов (например, статей в формате Markdown) в структурированный JSON, который используется в текущем приложении (Next.js 15, React 18) для подготовки к интервью.

Что важно в актуальной версии проекта:
- Поддерживаются три типа секций: `text`, `code_task`, `quiz` (изображения/видео пока не поддерживаются).
- В секции можно (опционально) хранить мини-чат `ai_chat_history`. Сообщения имеют поля `role` и `text`, `ts` — опционально.
- Файл урока для демо-страницы читается из `public/two_sum_full.json`. Чтобы проверить свой урок, временно замените этот файл.
- `text.content` поддерживает Markdown (включая GFM — таблицы, чекбоксы и т. п.).
- Для `code_task` тесты могут иметь произвольные входы/ожидаемые значения. Раннер извлекает имя первой объявленной в коде функции и вызывает её в тестах.

---

## Что изменилось

- Добавлено поле `"state"` в секции `code_task`: `"NOT_RESOLVED"`, `"RESOLVED"`, `"SKIPPED"`.
- Добавлено поле `"solution_code"` — эталонное решение, которое показывается при состоянии `"SKIPPED"`.
- В `ai_chat_history` сообщения могут включать код пользователя через поле `"code"` (например, текущий текст из редактора).
- Кнопка UI “Skip / Show solution” переводит секцию в `"SKIPPED"` и раскрывает `solution_code`.

Состояние проекта и совместимость сейчас:
- Текущая Zod-схема (`lib/schemas/lesson.ts`) ещё не включает `state`, `solution_code` и поле `code` у сообщений. При валидации неизвестные поля будут проигнорированы (не вызовут ошибку, но не появятся в нормализованных типах).
- UI текущей версии не использует `state`/`solution_code` и не отправляет код редактора в AI-запросах. Добавление этих полей в JSON — шаг “вперёд по совместимости”, но функционал заработает после обновления схемы и UI.

---

## 1. Общая структура JSON

Каждая тема — это JSON-объект с метаданными и списком секций:

```json
{
  "id": "two_sum",
  "title": "Two Sum — A complete, student-friendly guide",
  "difficulty": "easy",
  "topics": ["Array", "Hash Table"],
  "goal": "Given an array nums and an integer target...",
  "sections": [ { /* ... */ } ],
  "created_at": "2025-10-21T16:43:50.397Z"
}
```

Пояснения:
- `difficulty` — опционально; в приложении нормализуется к нижнему регистру (например, `"Easy"` → `"easy"`). Рекомендуемые значения: `easy`, `medium`, `hard`.
- `topics`, `goal`, `created_at` — опционально.

---

## 2. Типы секций

- `text` — теоретический материал в Markdown (поле `content`).
- `code_task` — практика написания кода (поля `starter_code`, `solution_code`, `tests`, `state`).
- `quiz` — мини-тест (список вопросов с вариантами и правильным ответом).

---

## 3. Поля секции `code_task`

```json
{
  "type": "code_task",
  "title": "Task title",
  "description": "Short explanation of what to implement.",
  "starter_code": "function example() {\n  // TODO: implement\n}",
  "solution_code": "function example() {\n  // Full working solution\n}",
  "tests": [
    { "input": { "nums": [2,7,11,15], "target": 9 }, "expected": [0,1] }
  ],
  "hints": ["Optional hint 1", "Optional hint 2"],
  "state": "NOT_RESOLVED",
  "ai_chat_history": []
}
```

Пояснения и рекомендации:
- `state`:
  - `NOT_RESOLVED` — по умолчанию, пользователь ещё не решил задачу;
  - `RESOLVED` — все тесты пройдены пользователем;
  - `SKIPPED` — пользователь нажал “Показать решение”, показываем `solution_code`.
- `starter_code` — минимальная заготовка функции. Важно: функция, которую будет вызывать раннер, должна быть объявлена первой в коде (например, `function twoSum(...) {}` или `const twoSum = (...) => {}`) — раннер извлекает имя первой объявленной функции.
- `solution_code` — эталонное решение (отображается при `SKIPPED`).
- `tests` — формат входов:
  - Массив аргументов: `input: [arg1, arg2]` вызывает `fn(arg1, arg2)`.
  - Объект: `input: {a: 1, b: 2}` вызывает `fn(1, 2)` в порядке полей объекта. Во избежание неоднозначности предпочтителен массив.
  - `name` у теста опционально; если не указано — название генерируется автоматически.

---

## 4. Мини-чаты (`ai_chat_history`)

Каждая секция может содержать мини-чат для взаимодействия с AI.

```json
"ai_chat_history": [
  { "role": "user", "text": "Как работает поиск в хэш-таблице?", "ts": 1697890000000 },
  { "role": "assistant", "text": "Хэш-таблица хранит пары ключ-значение и ищет по хэшу за O(1) в среднем." },
  { "role": "user", "text": "Почему тест падает?", "code": "function twoSum(nums, target){...}" }
]
```

Структура сообщения сейчас в схеме: `{ role: 'user' | 'assistant', text: string, ts?: number }`.
- Поле `code` в сообщениях — новое расширение (для передачи текущего кода из редактора в контексте `code_task`). Оно появится после обновления схемы; до этого будет проигнорировано валидатором.

---

## 5. Workflow UI (упрощённо)

| Действие | Изменение состояния |
| --- | --- |
| Студент пишет код и запускает тесты | Проверка тестов |
| Все тесты пройдены | `state = "RESOLVED"` |
| Нажата кнопка "Показать решение" | `state = "SKIPPED"`, показать `solution_code` |
| Отправка вопроса AI из `code_task` | В историю добавляется `{ role: 'user', text: '...', code: '...' }` (после обновления схемы) |

Примечание: в текущей кодовой базе передача кода в AI-запросах будет добавлена на уровне UI/API отдельно от содержимого JSON-урока.

---

## 6. Пример `quiz` секции

```json
{
  "type": "quiz",
  "title": "Quick check",
  "questions": [
    {
      "question": "What is the average time complexity of the hash map solution?",
      "options": ["O(n²)", "O(log n)", "O(n)", "O(1)"],
      "answer": "O(n)"
    }
  ],
  "ai_chat_history": []
}
```

Правила для викторины:
- В каждом вопросе `options` — минимум 2 варианта.
- `answer` должен совпадать с одним из вариантов из `options`.

---

## 7. Шаги ручного преобразования

1. Разбить исходный Markdown по логическим секциям.
2. Теорию перенести в `text`.
3. Примеры/задания перенести в `code_task`: заполнить `starter_code`, `solution_code`, `tests`, опционально `hints`.
4. Викторины перенести в `quiz`.
5. Для каждой `code_task` установить `state: "NOT_RESOLVED"` (по умолчанию).
6. По необходимости добавить `ai_chat_history` (или оставить пустым массивом).
7. Проверить JSON и сохранить в `public/two_sum_full.json` (демо-страница читает именно этот путь).

---

## 8. Пример готового блока `code_task`

```json
{
  "type": "code_task",
  "title": "One-pass Hash Map",
  "description": "Implement O(n) solution.",
  "starter_code": "function twoSum(nums, target) {\n  // TODO: implement using a hash map\n}",
  "solution_code": "function twoSum(nums, target) {\n  const seen = {};\n  for (let i = 0; i < nums.length; i++) {\n    const need = target - nums[i];\n    if (need in seen) return [seen[need], i];\n    seen[nums[i]] = i;\n  }\n  throw new Error('No two sum solution');\n}",
  "tests": [
    { "input": { "nums": [2,7,11,15], "target": 9 }, "expected": [0,1] }
  ],
  "hints": ["Check complement before insert"],
  "state": "NOT_RESOLVED",
  "ai_chat_history": []
}
```

---

## 9. Валидация и совместимость со схемой

- Актуальная схема: `lib/schemas/lesson.ts` (Zod). Нормализация приводит `difficulty` к нижнему регистру, добавляет `id` секциям и т. п.
- До обновления схемы поля `solution_code`, `state` и `ai_chat_history[].code` будут игнорироваться при валидации (они не вызовут ошибку, но не попадут в нормализованные типы). Это безопасно для хранения “на вырост”.
- После обновления схемы значения `state` будут ограничены перечислением `['NOT_RESOLVED', 'RESOLVED', 'SKIPPED']`.

Полезные подсказки:
- Соблюдайте порядок аргументов для функций в `code_task` тестах; надёжнее передавать входы массивом.
- В `text` используйте Markdown (GFM) — заголовки, списки, таблицы корректно отображаются.
